/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "check_test.check" instead.
 */

#include <check.h>
#include <locale.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include "s21_string.h"

#define LEN 256

START_TEST(strcat_multy) {
  struct input_data {
    char str1[LEN];
    const char *str2;
  };
  struct input_data testcases[] = {{"This is strcat test,", " we add this"},
                                   {"This is strcat test,", " we add this"},
                                   {"This is strcat test, add nothing", ""},
                                   {"This is strcat test, add nothing", ""},
                                   {"", "+cat to empty line"},
                                   {"", "+cat to empty line"},
                                   {"Try to cat with s21_NULL-term", "\0"},
                                   {"Try to cat with s21_NULL-term", "\0"},
                                   {"Cat with spaces", "     "},
                                   {"Cat with spaces", "     "}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i += 2) {
    char *result = s21_strcat(testcases[i].str1, testcases[i].str2);
    char *expected_result =
        strcat(testcases[i + 1].str1, testcases[i + 1].str2);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strncat_multy) {
  struct input_data {
    char str1[LEN];
    const char *str2;
    int n;
  };
  struct input_data testcases[] = {
      {"This is strncat test,", " we add till this! and more", 18},
      {"This is strncat test,", " we add till this! and more", 18},
      {"This is strncat test, add nothing", "", 10},
      {"This is strncat test, add nothing", "", 10},
      {"", "+cat to empty line", 10},
      {"", "+cat to empty line", 10},
      {"Try to n-cat 0 symbols", "aboba", 0},
      {"Try to n-cat 0 symbols", "aboba", 0},
      {"Cat several symbols from empty line", "", 5},
      {"Cat several symbols from empty line", "", 5},
      {"     ", "      ", 3},
      {"     ", "      ", 3}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i += 2) {
    char *result =
        s21_strncat(testcases[i].str1, testcases[i].str2, testcases[i].n);
    char *expected_result =
        strncat(testcases[i].str1, testcases[i + 1].str2, testcases[i + 1].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strerror_multy) {
  for (int i = -100; i < S21_ERRLIST_SIZE + 100; i++) {
    char *result = s21_strerror(i);
    char *expected_result = strerror(i);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strtok_multy) {
  struct input_data {
    char str[LEN];
    const char *delim;
  };
  struct input_data testcases[] = {{"This.is.the.string", "."},
                                   {"This.is.the.string", "."},
                                   {"this,.is,.the,.,.,.string,.", ",."},
                                   {"this,.is,.the,.,.,.string,.", ",."},
                                   {",.!,.!,.!,.!,.,.,.,!.", ",.!"},
                                   {",.!,.!,.!,.!,.,.,.,!.", ",.!"},
                                   {"This is the string", ",.!"},
                                   {"This is the string", ",.!"},
                                   {"", ",."},
                                   {"", ",."},
                                   {"This is the stirng", ""},
                                   {"This is the stirng", ""},
                                   {",.,.,.,,.,.The.,.,.,,.,.", ",."},
                                   {",.,.,.,,.,.The.,.,.,,.,.", ",."}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i += 2) {
    char *result = s21_strtok(testcases[i].str, testcases[i].delim);
    char *expected_result =
        strtok(testcases[i + 1].str, testcases[i + 1].delim);
    while (result && expected_result) {
      ck_assert_pstr_eq(result, expected_result);
      result = s21_strtok(s21_NULL, testcases[i].delim);
      expected_result = strtok(s21_NULL, testcases[i + 1].delim);
    }
    ck_assert_ptr_null(result);
    ck_assert_ptr_null(expected_result);
  }
}
END_TEST

START_TEST(strlen_multy) {
  struct input_data {
    const char *str1;
  };
  struct input_data testcases[] = {
      {"Hello"}, {"Hello world!"}, {"Hello world!!!"}, {""}, {"\0string"},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    s21_size_t result = s21_strlen(testcases[i].str1);
    s21_size_t expected_result = strlen(testcases[i].str1);
    ck_assert_uint_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strcspn_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
  };
  struct input_data testcases[] = {
      {"Hello world!", "Hello"},
      {"Hello world!", "Hello world"},
      {"Hello world!", "Hello world!"},
      {"", s21_NULL},
      {"\0string", ""},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    s21_size_t result = s21_strcspn(testcases[i].str1, testcases[i].str2);
    s21_size_t expected_result = strcspn(testcases[i].str1, testcases[i].str2);
    ck_assert_uint_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strspn_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
  };
  struct input_data testcases[] = {
      {"Hello world!", "Hello"},
      {"Hello world!", "Hello world"},
      {"Hello world!", "Hello world!"},
      {"", s21_NULL},
      {"\0string", ""},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    s21_size_t result = s21_strspn(testcases[i].str1, testcases[i].str2);
    s21_size_t expected_result = strspn(testcases[i].str1, testcases[i].str2);
    ck_assert_uint_eq(result, expected_result);
  }
}
END_TEST

START_TEST(memcmp_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
    s21_size_t n;
  };
  struct input_data testcases[] = {
      {"Hello world!", "Hello", 13},
      {"Hello world!", "Hello world!", 13},
      {"Hello world!", "Hello world!!!", 13},
      //{"", s21_NULL, 1},  Segmentation fault
      {"\0string", "", 1},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    int result =
        s21_memcmp(testcases[i].str1, testcases[i].str2, testcases[i].n);
    int expected_result =
        memcmp(testcases[i].str1, testcases[i].str2, testcases[i].n);
    ck_assert_int_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strcmp_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
  };
  struct input_data testcases[] = {
      {"Hello world!", "Hello"},
      {"Hello world!", "Hello world!"},
      {"Hello world!", "Hello world!!!"},
      //{"", s21_NULL},  Segmentation fault
      {"\0string", ""},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    int result = s21_strcmp(testcases[i].str1, testcases[i].str2);
    int expected_result = strcmp(testcases[i].str1, testcases[i].str2);
    ck_assert_int_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strncmp_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
    s21_size_t n;
  };
  struct input_data testcases[] = {
      {"Hello world!", "Hello", 13},
      {"Hello world!", "Hello world!", 13},
      {"Hello world!", "Hello world!!!", 13},
      //{"", s21_NULL, 1},  Segmentation fault
      {"\0string", "", 1},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
  for (s21_size_t i = 0; i < n; i++) {
    int result =
        s21_strncmp(testcases[i].str1, testcases[i].str2, testcases[i].n);
    int expected_result =
        strncmp(testcases[i].str1, testcases[i].str2, testcases[i].n);
    ck_assert_int_eq(result, expected_result);
  }
}
END_TEST

START_TEST(memcpy_multy) {
  char input_desc[][LEN] = {"aaaaaa", "12345", "\0"};
  const char *input_str[] = {"123321", "gf", ""};
  s21_size_t n[] = {4, 2, 0};
  s21_size_t len = sizeof(n) / sizeof(s21_size_t);

  char copy[LEN];
  for (s21_size_t i = 0; i < len; i++) {
    strcpy(copy, input_desc[i]);
    char *result = s21_memcpy(input_desc[i], input_str[i], n[i]);
    char *expected_result = memcpy(copy, input_str[i], n[i]);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(memmove_simple) {
  char input_desc[][LEN] = {"aaaaaa", "\0"};
  const char *input_str[] = {"123321", ""};
  s21_size_t n[] = {4, 0};
  s21_size_t len = sizeof(n) / sizeof(s21_size_t);

  char copy[LEN];
  for (s21_size_t i = 0; i < len; i++) {
    char *result, *expected_result;
    strcpy(copy, input_desc[i]);
    result = s21_memcpy(input_desc[i], input_str[i], n[i]);
    expected_result = memcpy(copy, input_str[i], n[i]);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(memmove_crossmemory) {
  char spec_test[] = "hello_iam";
  char *s1 = spec_test;
  char *s2 = spec_test + 2;
  char copy_s1[LEN], copy_s2[LEN];
  strcpy(copy_s1, s1);
  strcpy(copy_s2, s2);

  char *result = s21_memmove(s1, s2, 4);
  char *expected_result = memmove(copy_s1, copy_s2, 4);
  ck_assert_pstr_eq(result, expected_result);

  s1 = spec_test;
  s2 = spec_test + 2;
  strcpy(copy_s1, s1);
  strcpy(copy_s2, s2);
  result = s21_memmove(s2, s1, 4);
  expected_result = memmove(copy_s2, copy_s1, 4);
  ck_assert_pstr_eq(result, expected_result);
}
END_TEST

START_TEST(memset_multy) {
  char input_desc[][LEN] = {"aaaaaa", "1234", "000"};
  const char input_symbol[] = {'c', 'b', '\0'};
  s21_size_t n[] = {4, 0, 2};
  s21_size_t len = sizeof(n) / sizeof(s21_size_t);
  char copy[LEN];

  for (s21_size_t i = 0; i < len; i++) {
    char *result, *expected_result;
    strcpy(copy, input_desc[i]);
    result = s21_memset(input_desc[i], input_symbol[i], n[i]);
    expected_result = memset(copy, input_symbol[i], n[i]);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strcpy_multy) {
  char input_desc[][LEN] = {"aaaaaa", "12345", "qwe"};
  const char *input_str[] = {"123", "", "\0"};
  s21_size_t len = sizeof(input_desc) / sizeof(char[LEN]);
  char copy[LEN];

  for (s21_size_t i = 0; i < len; i++) {
    strcpy(copy, input_desc[i]);
    char *result = s21_strcpy(input_desc[i], input_str[i]);
    char *expected_result = strcpy(copy, input_str[i]);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strncpy_multy) {
  char input_desc[][LEN] = {"aaaaaa", "12345", "qwe", "fdas"};
  const char *input_str[] = {"123", "", "\0", "fd"};
  s21_size_t n[] = {4, 1, 2, 0};
  s21_size_t len = sizeof(n) / sizeof(s21_size_t);
  char copy[LEN];

  for (s21_size_t i = 0; i < len; i++) {
    strcpy(copy, input_desc[i]);
    char *result = s21_strncpy(input_desc[i], input_str[i], n[i]);
    char *expected_result = strncpy(copy, input_str[i], n[i]);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(memchr_multy) {
  struct input_data {
    const char *str;
    int c;
    s21_size_t n;
  };
  struct input_data testcases[] = {
      {"aaaabaaa", 'b', 8}, {"aaaabaaa", 'b', 4}, {"cccccccc", 'b', 8},
      {"", '\0', 1},        {"\0string", 's', 8},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    void *result = s21_memchr(testcases[i].str, testcases[i].c, testcases[i].n);
    void *expected_result =
        memchr(testcases[i].str, testcases[i].c, testcases[i].n);
    ck_assert_ptr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strchr_multy) {
  struct input_data {
    const char *str;
    int c;
  };
  struct input_data testcases[] = {
      {"aaaabaaa", 'b'}, {"aaaabaaa", 'b'}, {"cccccccc", 'b'},
      {"ab", '\0'},      {"\0string", 's'},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char *result = s21_strchr(testcases[i].str, testcases[i].c);
    char *expected_result = strchr(testcases[i].str, testcases[i].c);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strpbrk_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
  };
  struct input_data testcases[] = {{"Hello world!", "w!"},
                                   {"Hello world!", " d"},
                                   {"Marco", "P0l0"},
                                   {"Lol", "\0"},
                                   {"Aboba", ""}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char *result = s21_strpbrk(testcases[i].str1, testcases[i].str2);
    char *expected_result = strpbrk(testcases[i].str1, testcases[i].str2);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strrchr_multy) {
  struct input_data {
    const char *str;
    int c;
  };
  struct input_data testcases[] = {{"Hello World!", 'o'},
                                   {"", '\0'},
                                   {"aboba", 'a'},
                                   {"arbuz", '\0'},
                                   {"once", 'a'}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char *result = s21_strrchr(testcases[i].str, testcases[i].c);
    char *expected_result = strrchr(testcases[i].str, testcases[i].c);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(strstr_multy) {
  struct input_data {
    const char *haystack;
    const char *needle;
  };
  struct input_data testcases[] = {{"Hello world!", "world"},
                                   {"Hello world!", "Goodbye"},
                                   {"Hello world!", ""},
                                   {"", ""},
                                   {"What\0HEY", "HEY"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char *result = s21_strstr(testcases[i].haystack, testcases[i].needle);
    char *expected_result = strstr(testcases[i].haystack, testcases[i].needle);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(to_upper_single) {
  const char str1[] = "English, motherfucker, DO YOU SPEAK IT?!123450";
  char *result = (char *)s21_to_upper(str1);
  char *expected_result = "ENGLISH, MOTHERFUCKER, DO YOU SPEAK IT?!123450";
  ck_assert_pstr_eq(result, expected_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(to_lower_single) {
  const char str1[] = "123450English, motherfucker, DO YOU SPEAK IT?!";
  char *result = (char *)s21_to_lower(str1);
  char *expected_result = "123450english, motherfucker, do you speak it?!";
  ck_assert_pstr_eq(result, expected_result);
  if (result) {
    free(result);
  }
}
END_TEST

START_TEST(insert_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
    s21_size_t index;
  };
  struct input_data cases[] = {{"I'm a poor boy", " just", 3},
                               {"I need no", " sympathy", 9},
                               {"easy go", "Beacuse I'm easy come, ", 0},
                               {"I need no", " sympathy", 19},
                               {"I need no", "", 0},
                               {"", "", 0},
                               {"", " ", 0},
                               {" ", "", 0},
                               {" ", " ", 0}};
  char *expected_result[] = {"I'm just a poor boy",
                             "I need no sympathy",
                             "Beacuse I'm easy come, easy go",
                             s21_NULL,
                             "I need no",
                             "",
                             " ",
                             " ",
                             "  "};
  s21_size_t n = sizeof(cases) / sizeof(cases[0]);
  for (s21_size_t i = 0; i < n; i++) {
    char *result =
        (char *)s21_insert(cases[i].str1, cases[i].str2, cases[i].index);
    ck_assert_pstr_eq(result, expected_result[i]);
    if (result) {
      free(result);
    }
  }
}
END_TEST

START_TEST(trim_multy) {
  struct input_data {
    const char *str1;
    const char *str2;
  };
  struct input_data cases[] = {
      {"Floor! Let the bodies hit the Floor!", "Floor !"},
      {"p p p Poker face", "p "},
      {"Oh no no no", "no "},
      {"Oh no no no", "yes "},
      {"aaa", "a"},
      {" ", ""},
      {"", " "},
      {"      ", "       "}};
  char *expected_result[] = {"Let the bodies hit the",
                             "Poker face",
                             "Oh",
                             "Oh no no no",
                             "",
                             " ",
                             "",
                             ""};
  s21_size_t n = sizeof(cases) / sizeof(cases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char *result = (char *)s21_trim(cases[i].str1, cases[i].str2);
    ck_assert_pstr_eq(result, expected_result[i]);
    if (result) {
      free(result);
    }
  }
}
END_TEST

START_TEST(sprintf_c_single) {
  struct input_data {
    const char *format;
    const char c;
  };
  struct input_data testcases[] = {{"%c", 'a'},      {"%c", ' '},
                                   {"%%%c", 'a'},    {"%04.3c", 'a'},
                                   {"%-04.0c", 'a'}, {"%04.9c", 'a'}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].c);
    sprintf(expected_result, testcases[i].format, testcases[i].c);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_lc_single) {
  struct input_data {
    const char *format;
    const wchar_t c;
  };
  struct input_data testcases[] = {{"%lc", L'х'},    {"%lc", L' '},
                                   {"%%%lc", L'ш'},  {"%40lc", L'Ȭ'},
                                   {"%-04lc", L'Ȭ'}, {"%04.6lc", L'ƾ'}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].c);
    sprintf(expected_result, testcases[i].format, testcases[i].c);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_c_multy) {
  struct input_data {
    const char *format;
    const char c1;
    const char c2;
    const char c3;
  };
  struct input_data_precision {
    const char *format;
    const char c1;
    const int pr;
    const char c2;
  };
  struct input_data testcases[] = {
      {"%c%c%c", 'a', 'b', 'c'},         {"%c%c%c", '\t', ' ', '\n'},
      {"%%%c%0c%%%c", 'a', 'b', 'c'},    {"%4c%05c%6c", 'a', 'b', 'c'},
      {"%1c%02c%1c", 'a', 'd', 'g'},     {"%-4c%-5c%-6c", 'a', 'b', 'c'},
      {"%-4.3c%5.2c%-6c", 'a', 'b', 'c'}};
  struct input_data_precision testcases_pr[] = {
      {"%04c%*c", 'a', 4, 'c'},     {"%1c%.*c", 'a', 4, 'd'},
      {"%04c%*c", 'a', 1, 'b'},     {"%-6c%.*c", 'a', 1, 'b'},
      {"%02.2c%*.0c", 'a', 5, 'd'}, {"%-5c%5.*c", 'a', 5, 'b'},
      {"%5c%*.5c", 'a', -5, 'd'},   {"%-2c%5.*c", 'a', 0, 'b'},
  };
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].c1, testcases[i].c2,
                testcases[i].c3);
    sprintf(expected_result, testcases[i].format, testcases[i].c1,
            testcases[i].c2, testcases[i].c3);
    ck_assert_pstr_eq(result, expected_result);
  }
  s21_size_t m = sizeof(testcases_pr) / sizeof(testcases_pr[0]);
  for (s21_size_t i = 0; i < m; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases_pr[i].format, testcases_pr[i].c1,
                testcases_pr[i].pr, testcases_pr[i].c2);
    sprintf(expected_result, testcases_pr[i].format, testcases_pr[i].c1,
            testcases_pr[i].pr, testcases_pr[i].c2);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_s_single) {
  struct input_data {
    const char *format;
    const char *s;
  };
  struct input_data testcases[] = {
      {"%s", "Aboba string"},    {"%s", "  \t "},
      {"%%%s", "Aboba string"},  {"%040.2s", "Aboba string"},
      {"%-40s", "Aboba string"}, {"%-040.40s", "Aboba string"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].s);
    sprintf(expected_result, testcases[i].format, testcases[i].s);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_ls_single) {
  struct input_data {
    const char *format;
    const wchar_t *s;
  };
  struct input_data testcases[] = {{"%ls", L"Мы адепты кириллицы"},
                                   {"%ls", L"  \t "},
                                   {"%%%ls", L"हिंदी में पाठ"},
                                   {"%040ls", L"Косово је Србија"},
                                   {"%-40.2ls", L"Ez bi kurdî dinivîsim"},
                                   {"%40.40ls", L"日本"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].s);
    sprintf(expected_result, testcases[i].format, testcases[i].s);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_di_single) {
  struct input_data {
    const char *format;
    const int n;
  };
  struct input_data testcases[] = {
      {"%d", 123},    {"%%%d", -123},  {"%4d", 123},     {"%4d", 123456},
      {"%04d", 123},  {"%+4d", 123},   {"%+05d", 123},   {"% d", 123456},
      {"%-4d", 123},  {"%+5.5d", 123}, {"% 5d", -123},   {"%.5d", 123},
      {"%+.5d", 123}, {"%-.5d", 123},  {"%.3d", 123456}, {"%i", 123},
      {"%%%i", -123}, {"%4i", 123},    {"%4i", 123456},  {"%04i", 0},
      {"%+4i", 123},  {"%+05i", 123},  {"% i", 0},       {"%-4i", 123},
      {"%+05i", 123}, {"% 5i", -0},    {"%.5i", 123},    {"%+.5i", 123},
      {"%-.5i", 123}, {"%.3i", 123456}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_hdi_single) {
  struct input_data {
    const char *format;
    const short int n;
  };
  struct input_data testcases[] = {
      {"%hd", 123},     {"%%%hd", -123},  {"%4hd", 123},    {"%4hd", 1234},
      {"%04hd", 123},   {"%+4hd", 123},   {"%+05hd", 123},  {"% hd", 1256},
      {"%-4hd", 123},   {"%+5.5hd", 123}, {"% 5hd", -123},  {"%.5hd", 123},
      {"%+.5hd", 123},  {"%-.5hd", 123},  {"%.3hd", 1234},  {"%i", 123},
      {"%%%0hi", -123}, {"%04hi", 123},   {"%+04hi", 1256}, {"%04hi", 0},
      {"%+4hi", 123},   {"%+05hi", 123},  {"% 4hi", 0},     {"%-4hi", 123},
      {"%+05hi", 123},  {"% 05hi", -0},   {"%.5hi", 123},   {"%+.5hi", 123},
      {"%-.5hi", 123},  {"%.3hi", 3456}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_ldi_single) {
  struct input_data {
    const char *format;
    const long int n;
  };
  struct input_data testcases[] = {
      {"%ld", 123},    {"%%%ld", -123},  {"%4ld", 123},      {"%4ld", 123456},
      {"%04ld", 123},  {"%+4ld", 123},   {"%+05ld", 123},    {"% ld", 123456},
      {"%-4ld", 123},  {"%+5.5ld", 123}, {"% 5ld", -123},    {"%.5ld", 123},
      {"%+.5ld", 123}, {"%-.5ld", 123},  {"%.3ld", 123456},  {"%li", 123},
      {"%%%0i", -123}, {"%04li", 123},   {"%+04li", 123456}, {"%04li", 0},
      {"%+4li", 123},  {"%+05li", 123},  {"% 4li", 0},       {"%-4li", 123},
      {"%+05li", 123}, {"% 05li", -0},   {"%.5li", 123},     {"%+.5li", 123},
      {"%-.5li", 123}, {"%.3li", 123456}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_p_single) {
  const char *format = "%p%p";
  const double d_array[5] = {1., 2., 3., 4., 5.};
  const char *c_array = "abcde";

  for (int i = 0; i < 5; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, format, &d_array[i], &c_array[i]);
    sprintf(expected_result, format, &d_array[i], &c_array[i]);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_di_multy) {
  struct input_data {
    const char *format;
    const int n1;
    const int n2;
    const int n3;
  };
  struct input_data testcases[] = {{"%d%d%d", 1, 2, 3},
                                   {"%%%d%d%d", -1, 2, -3},
                                   {"%4d%3d%2d", 1, 234, 5678},
                                   {"%1d%1d%1d", 111, -222, 333},
                                   {"%04d%*d", -1, 2, -3},
                                   {"%+4d%5.*d", 1, 2, 5678},
                                   {"%+05d%1d%+1d", 111, -222, 333},
                                   {"% -d%*d", -1, 2, -3},
                                   {"%-4d%-2.*d", 1, 2, 5678},
                                   {"%+01d%+5.5d% d", 111, -222, 333},
                                   {"% -d%*d", -1, 5, -3},
                                   {"%-4d%+5.*d", 1, 7, 5678},
                                   {"%+.5d%-5.5d% d", 111, 222, 123456},
                                   {"% -.5d%*d", -1, 5, 2},
                                   {"%.3d%+3.*d", 12345, 7, 0},
                                   {"%d%i%d", 1, 2, 3},
                                   {"%%%i%d%i", -1, 2, -3},
                                   {"%4d%3i%2i", 1, 234, 5678},
                                   {"%1i%1i%1i", 111, -222, 333},
                                   {"%04i%*d", -1, 2, -3},
                                   {"%+4d%5.*i", 1, 2, 5678},
                                   {"%+05i%1d%+1i", 111, -222, 333},
                                   {"% -d%*i", -1, 2, -3},
                                   {"%-4i%-2.*d", 1, 2, 5678}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n1, testcases[i].n2,
                testcases[i].n3);
    sprintf(expected_result, testcases[i].format, testcases[i].n1,
            testcases[i].n2, testcases[i].n3);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_dioxu_long) {
  struct input_data {
    const char *format;
    const int n1;
    const int n2;
    const int n3;
  };
  struct input_data testcases[] = {
      {"%d%i%o", 2147483647, -2147483648, 999999999},
      {"%%%d%d%d", 2147483647, -2147483648, 999999999},
      {"%4o%3i%2u", 2147483647, -2147483648, 999999999},
      {"%1d%1d%1d", 2147483647, -0, -2147483648},
      {"%04d%*d", 2147483647, 3, -2147483648},
      {"%+4x%5.*d", 2147483647, 3, -2147483648},
      {"%+05u%1o%+1d", 2147483647, 0, -2147483648},
      {"% -d%*d", 2147483647, 20, -2147483648},
      {"%-4x%-2.*d", 2147483647, 20, -2147483648},
      {"%+01u%+5.5d% d", 2147483647, -2147483648, -2147483648},
      {"% -o%*d", 2147483647, 0, -2147483648},
      {"%-4o%+5.*d", 2147483647, 0, -2147483648},
      {"%+.5x%-5.5d% d", 2147483647, 1234567890, 123456},
      {"% -.5u%*d", 2147483647, 5, -2147483648},
      {"%.3o%+3.*d", 2147483647, 7, -2147483648},
      {"%x%i%d", 2147483647, 0, -2147483648},
      {"%%%u%d%i", 2147483647, 0, -2147483648},
      {"%4d%3i%2i", 2147483647, 1234567890, -2147483648},
      {"%1i%1i%1i", 2147483647, -222, -2147483648},
      {"%04i%*d", 2147483647, 2, -2147483648},
      {"%+4d%5.*i", 2147483647, 2, -2147483648},
      {"%+05i%1d%+1i", 2147483647, -222, -2147483648},
      {"% -x%*i", 2147483647, 0, -2147483648},
      {"%-4i%-2.*d", 2147483647, 0, -2147483648}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n1, testcases[i].n2,
                testcases[i].n3);
    sprintf(expected_result, testcases[i].format, testcases[i].n1,
            testcases[i].n2, testcases[i].n3);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_oxu_multy) {
  struct input_data {
    const char *format;
    const int n1;
    const int n2;
    const int n3;
  };
  struct input_data testcases[] = {{"%o%o%#o", 1, 9, 15},
                                   {"%u%u%#u", 1, 9, 15},
                                   {"%x%x%#x", 1, 15, 16},
                                   {"%X%X%#X", 1, 15, 16},
                                   {"%4o%3u%#2x", 100, 234, 5678},
                                   {"%1X%1o%1u", 111, 222, 333},
                                   {"%04x%*X", 99, 2, 99},
                                   {"%+4o%5.*u", 1, 5, 100},
                                   {"%+05x%#1X%+1o", 111, 222, 333},
                                   {"% -u%*x", 1, 2, 15},
                                   {"%#-4X%-2.*o", 14, 0, 0},
                                   {"%#+01u%+5.5x% X", 111, 222, 333},
                                   {"% -o%*u", 11, 5, 3},
                                   {"%-4x%+5.*X", 1, 7, 5678},
                                   {"%+.5o%-5.5u%# x", 111, 222, 123456},
                                   {"% -.5X%*o", 21, 5, 21},
                                   {"%.3u%+3.*x", 12345, 7, 0},
                                   {"%#X%#o%u", 21, 21, 21},
                                   {"%%%x%X%o", 21, 21, 21},
                                   {"%4u%3x%2X", 212121, 212121, 212121},
                                   {"%1o%1u%1x", 111, 222, 333},
                                   {"%04X%*o", 11, 2, 123},
                                   {"%+4u%5.*x", 404, 0, 0},
                                   {"%+05X%1o%+1u", 111, 222, 0},
                                   {"%# -x%*X", 13, 2, 14},
                                   {"%-4o%-#2.*u", 64, 2, 5678}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n1, testcases[i].n2,
                testcases[i].n3);
    sprintf(expected_result, testcases[i].format, testcases[i].n1,
            testcases[i].n2, testcases[i].n3);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_hoxu_multy) {
  struct input_data {
    const char *format;
    const short int n1;
    const short int n2;
    const short int n3;
  };
  struct input_data testcases[] = {{"%ho%ho%#ho", 1, 9, 15},
                                   {"%hu%hu%#hu", 1, 9, 15},
                                   {"%hx%hx%#hx", 1, 15, 16},
                                   {"%hX%hX%#hX", 1, 15, 16},
                                   {"%4ho%3hu%#2hx", 100, 234, 5678},
                                   {"%1hX%1ho%1hu", 111, 222, 333},
                                   {"%04hx%*hX", 99, 2, 99},
                                   {"%+4ho%5.*hu", 1, 5, 100},
                                   {"%+05hx%#1hX%+1ho", 111, 222, 333},
                                   {"% -hu%*hx", 1, 2, 15},
                                   {"%#-4hX%-2.*ho", 14, 0, 0},
                                   {"%#+01hu%+5.5hx% X", 111, 222, 333},
                                   {"% -ho%*hu", 11, 5, 3},
                                   {"%-4hx%+5.*hX", 1, 7, 5678},
                                   {"%+.5ho%-5.5hu%# hx", 111, 222, 1236},
                                   {"% -.5hX%*ho", 21, 5, 21},
                                   {"%.3hu%+3.*hx", 12345, 7, 0},
                                   {"%#hX%#ho%hu", 21, 21, 21},
                                   {"%%%hx%hX%ho", 21, 21, 21},
                                   {"%4hu%3hx%2hX", 21221, 21121, 21221},
                                   {"%1ho%1hu%1hx", 111, 222, 333},
                                   {"%04hX%*ho", 11, 2, 123},
                                   {"%+4hu%5.*hx", 404, 0, 0},
                                   {"%+05hX%1ho%+1hu", 111, 222, 0},
                                   {"%# -hx%*hX", 13, 2, 14},
                                   {"%-4ho%-#2.*hu", 64, 2, 5678}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n1, testcases[i].n2,
                testcases[i].n3);
    sprintf(expected_result, testcases[i].format, testcases[i].n1,
            testcases[i].n2, testcases[i].n3);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_loxu_multy) {
  struct input_data {
    const char *format;
    const long int n1;
    const long int n2;
    const long int n3;
  };
  struct input_data testcases[] = {{"%lo%lo%#lo", 1, 9, 15},
                                   {"%lu%lu%#lu", 1, 9, 15},
                                   {"%lx%lx%#lx", 1, 15, 16},
                                   {"%lX%lX%#lX", 1, 15, 16},
                                   {"%4lo%3lu%#2lx", 100, 234, 5678},
                                   {"%1lX%1lo%1lu", 111, 222, 333},
                                   {"%04lx%*lX", 99, 2, 99},
                                   {"%+4lo%+50.*lu", 1, 5, 100},
                                   {"%+05lx%#1lX%+1lo", 111, 222, 333},
                                   {"% -lu%*lx", 1, 2, 15},
                                   {"%#-4lX%-0.*lo", 14, 0, 0},
                                   {"%#+01lu%+5.5lx% X", 111, 222, 333},
                                   {"% -lo%*lu", 11, 5, 3},
                                   {"%-4lx%+5.*lX", 1, 7, 5678},
                                   {"%+.5lo%-5.0lu%# lx", 111, 222, 123456},
                                   {"% -.5lX%*lo", 21, 5, 21},
                                   {"%.3lu%+3.*lx", 12345, 7, 0},
                                   {"%#lX%#lo%lu", 21, 21, 21},
                                   {"%%%lx%lX%lo", 21, 21, 21},
                                   {"%4lu%3lx% 2lX", 212121, 212121, 212121},
                                   {"%1lo%1lu% 10lx", 111, 222, 333},
                                   {"%04lX%*lo", 11, 2, 123},
                                   {"%+4lu%5.*lx", 404, 0, 0},
                                   {"%+05lX%1lo%+1lu", 111, 222, 0},
                                   {"%# -lx%*lX", 13, 2, 14},
                                   {"%-4lo%-#2.*lu", 64, 2, 5678}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n1, testcases[i].n2,
                testcases[i].n3);
    sprintf(expected_result, testcases[i].format, testcases[i].n1,
            testcases[i].n2, testcases[i].n3);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_f_single) {
  struct input_data {
    const char *format;
    const double n;
  };
  struct input_data testcases[] = {{"%f", 1.23},          {"%%%f", -1.23},
                                   {"%4f", 1.23},         {"%4f", 12.3456},
                                   {"%04f", 1.23},        {"%+4f", 1.23},
                                   {"%+05f", 1.23},       {"% .2f", 12.3456},
                                   {"%-4f", 1.23},        {"%+5.5f", 1.23},
                                   {"% 5f", -1.23},       {"%.5f", 1.23},
                                   {"%+10.5f", 1.234445}, {"%-10.5f", 123},
                                   {"%.3f", 1.23456},     {"%#f", 1},
                                   {"%%%#f", -123},       {"%#.3f", 1.23},
                                   {"%+#f", 12.3456},     {"%0#f", 1.23},
                                   {"%#-4.1f", 123},      {"%+#05.1f", 1.23},
                                   {"% #f", 123},         {"%-# 7f", 12.3}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_Lf_single) {
  struct input_data {
    const char *format;
    const long double n;
  };
  struct input_data testcases[] = {{"%Lf", 1.23},          {"%%%Lf", -1.23},
                                   {"%4Lf", 1.23},         {"%1.1Lf", 12.3456},
                                   {"%04Lf", 1.23},        {"%+4.0Lf", 1.23},
                                   {"%+05Lf", 1.23},       {"% .2Lf", 12.3456},
                                   {"%-4Lf", 1.23},        {"%+5.5Lf", 1.23},
                                   {"% 5Lf", -1.23},       {"%.5Lf", 1.23},
                                   {"%+10.5Lf", 1.234445}, {"%-10.5Lf", 123},
                                   {"%.3Lf", 1.23456},     {"%#Lf", 1},
                                   {"%%%#Lf", -123},       {"%#.3Lf", 0},
                                   {"%+#Lf", 12.3456},     {"%0#Lf", 0},
                                   {"%#-4.1Lf", 123},      {"%+#05.1Lf", 0},
                                   {"% #Lf", 123},         {"%-# 7.0Lf", 0}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_e_single) {
  struct input_data {
    const char *format;
    const double n;
  };
  struct input_data testcases[] = {{"%e", 1.23},          {"%%%e", -1.23},
                                   {"%4e", 1.23},         {"%4e", 12.3456},
                                   {"%04E", 1.23},        {"%+4e", 1.23},
                                   {"%+05E", 1.23},       {"% e", 12.3456},
                                   {"%-4E", 1.23},        {"%+5.0e", 1.23},
                                   {"% 5E", -1.23},       {"%.5e", 1.23},
                                   {"%+10.2E", 1.234545}, {"%-10.5e", 123},
                                   {"%.3E", 1.23456},     {"%#e", 1},
                                   {"%%%#E", -123},       {"%#.1e", 1.2876},
                                   {"%+#E", 12.3456},     {"%0#e", 1.23},
                                   {"%#-4E", 123},        {"%+#05e", 1.23},
                                   {"% #E", 123},         {"%-# 7e", 12.3}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_LE_single) {
  struct input_data {
    const char *format;
    const long double n;
  };
  struct input_data testcases[] = {{"%Le", 1.23},          {"%%%Le", -1.23},
                                   {"%4Le", 1.23},         {"%4Le", 12.3456},
                                   {"%04LE", 1.23},        {"%+4Le", 1.23},
                                   {"%+05LE", 1.23},       {"% Le", 12.3456},
                                   {"%-4LE", 1.23},        {"%+5.0Le", 1.23},
                                   {"% 5LE", -1.23},       {"%.5Le", 1.23},
                                   {"%+10.2LE", 1.234545}, {"%-10.5Le", 123},
                                   {"%.3LE", 1.23456},     {"%#Le", 1},
                                   {"%%%#LE", -123},       {"%#.1Le", 1.2876},
                                   {"%+#LE", 12.3456},     {"%0#Le", 1.23},
                                   {"%#-4LE", 123},        {"%+#05Le", 1.23},
                                   {"% #LE", 123},         {"%-# 7Le", 12.3}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_g_single) {
  struct input_data {
    const char *format;
    const double n;
  };
  struct input_data testcases[] = {{"%g", 1.23},          {"%%%g", -1.23},
                                   {"%4g", 1.23},         {"%4g", 12.3456},
                                   {"%04g", 1.23},        {"%+4G", 1.23},
                                   {"%+09g", 9000.00},    {"% G", 12.3456},
                                   {"%-4g", 1.23},        {"%+5.5G", 1.23},
                                   {"% 5g", -1.23},       {"%.5G", 1.23},
                                   {"%+10.5g", 1.234445}, {"%-10.5G", 12300000},
                                   {"%.3g", 1.23456},     {"%#G", 1},
                                   {"%%%#g", -123},       {"%#G", 1.10000},
                                   {"%+#g", 12.3456},     {"%0#G", 1.23},
                                   {"%#-4g", 123},        {"%+#05G", 1.23},
                                   {"% #g", 123},         {"%-# 7G", 120000}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_LG_single) {
  struct input_data {
    const char *format;
    const long double n;
  };
  struct input_data testcases[] = {
      {"%Lg", 1.23},          {"%%%Lg", -1.23},
      {"%4Lg", 1.23},         {"%4Lg", 12.3456},
      {"% 04Lg", 0},          {"%+4LG", 1.23},
      {"%+09Lg", 9000.00},    {"% LG", 12.3456},
      {"% -4.4Lg", 1.23},     {"%+5.5LG", 1.23},
      {"% 5Lg", -1.23},       {"%.5LG", 1.23},
      {"%+10.5Lg", 1.234445}, {"%-10.5LG", 12300000},
      {"%4.0Lg", 0},          {"%#LG", 0},
      {"%%%#Lg", -123},       {"% #LG", 1.10000},
      {"%+#Lg", 12.3456},     {"%0#LG", 1.23},
      {"%#-4Lg", 123},        {"%+#05LG", 1.23},
      {"% #Lg", 123},         {"%-# 7LG", 120000}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_feg_single_long) {
  struct input_data {
    const char *format;
    const double n;
  };
  struct input_data testcases[] = {
      {"%f", -340282346638528859811704183484516925440.0000000000000000},
      {"%%%f", 340282346638528859811704183484516925440.0000000000000000},
      {"%4e", -340282346638528859811704183484516925440.0000000000000000},
      {"%4e", 340282346638528859811704183484516925440.0000000000000000},
      {"%04g", -340282346638528859811704183484516925440.0000000000000000},
      {"%+4g", 340282346638528859811704183484516925440.0000000000000000},
      {"%+05f", 340282346638528859811704183484516925439.999999999999},
      {"% .2f", -340282346638528859811704183484516925439.899999999999},
      {"%-4e", 340282346638528859811704183484516925439.999999999999},
      {"%+5.5e", -340282346638528859811704183484516925439.999999999999},
      {"% 5g", 340282346638528859811704183484516925439.999999999999},
      {"%.5g", -340282346638528859811704183484516925439.999999999999},
      {"%+50.10f", 340282346638528859811704183484516925440.0000000000000000},
      {"%-10.0f", -340282346638528859811704183484516925439.444999999999},
      {"%.0e", 340282346638528859811704183484516925439.9999999999},
      {"%#e", -340282346638528859811704183484516925439.999999999999},
      {"%%%#g", 340282346638528859811704183484516925440.0000000000000000},
      {"%50.15g", 000000000000000000000000.0000000000000000},
      {"%+#f", 340282346638528859811704183484516925440.0000000000000000},
      {"%0#f", -340282346638528859811704183484516925439.999999999999},
      {"%#-50.10e", 340282346638528859811704183484516925440.0000000000000000},
      {"%+#05.0e", -340282346638528859811704183484516925439.899999999999},
      {"% #g", 340282346638528859811704183484516925440.0000000000000000},
      {"%-# 7g", -340282346638528859811704183484516925439.999999999999}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    s21_sprintf(result, testcases[i].format, testcases[i].n);
    sprintf(expected_result, testcases[i].format, testcases[i].n);
    ck_assert_pstr_eq(result, expected_result);
  }
}
END_TEST

START_TEST(sprintf_hard) {
  struct input_data {
    const char *format;
    const char c;
    const int d;
    const unsigned long int ul_i;
    const char *s;
    const char *p;
    const int o_i;
    const short int hx_i;
    const double f;
    const long double L_e;
    const long double L_g;
  };
  char *test_p = "abcdef";
  struct input_data testcases[] = {
      {"Hard %c rock %d hard %lu %nrock %s hard %p rock %o hard %hx rock %f "
       "hard "
       "%Le rock %Lg!!!",
       'z', 1, 1, "xyz", &test_p[0], 1, 1, 1., 1., 1.},
      {"Hard   %4c rock %5d hard %1lu %nrock %2s hard %p rock %% %5o hard "
       "%05hx  %%%%rock %5f hard "
       "%05Le \trock %+Lg!!!",
       'z', 1, 12345, "xyz", &test_p[1], 1, 1, 1., 1., 1.},
      {"Hard %-4c rock %-5d hard %5lu %nrock %-5s hard %p rock %-4o hard %-3hx "
       "rock %-2f hard "
       "%-1Le rock %-10Lg!!!",
       'z', 1, 1, "xyz", &test_p[2], 1, 1, 1., 1., 210000.00},
      {"Hard %1c rock % +04d hard % 04.4lu %nrock %10s hard %p rock % #04o "
       "hard "
       "% #04.4hx rock % #f hard "
       "% #-5Le rock %+-#5.2Lg!!!",
       'z', 1, 1, "xyz", &test_p[4], 1, 1, 1., 1., 1.245}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result[LEN];
    char expected_result[LEN];
    int n1;
    int n2;
    s21_sprintf(result, testcases[i].format, testcases[i].c, testcases[i].d,
                testcases[i].ul_i, &n1, testcases[i].s, testcases[i].p,
                testcases[i].o_i, testcases[i].hx_i, testcases[i].f,
                testcases[i].L_e, testcases[i].L_g);
    sprintf(expected_result, testcases[i].format, testcases[i].c,
            testcases[i].d, testcases[i].ul_i, &n2, testcases[i].s,
            testcases[i].p, testcases[i].o_i, testcases[i].hx_i, testcases[i].f,
            testcases[i].L_e, testcases[i].L_g);
    ck_assert_pstr_eq(result, expected_result);
    ck_assert_int_eq(n1, n2);
  }
}
END_TEST

START_TEST(sscanf_c_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"e", "%c"},
                                   {"        e      ", "%c"},
                                   {"       %e        ", " %%%c"},
                                   {"   x n    ", "%2c"},
                                   {"       xc    e     ", "%-03.0c"},
                                   {"\t\tx", "%0c"},
                                   {"        y    ", "%        c"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result_first_arg[LEN] = {0};
    char expected_first_arg[LEN] = {0};
    int result = 0;
    int expected_result = 0;
    result =
        s21_sscanf(testcases[i].data, testcases[i].format, result_first_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, expected_first_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_pstr_eq(result_first_arg, expected_first_arg);
  }
}
END_TEST

START_TEST(sscanf_lc_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"e", "%lc"},
                                   {"        e      ", " %lc"},
                                   {"        ш        ", "%%%lc"},
                                   {"   ф а к т ы    ", "%2c"},
                                   {"        𓁅    ", "%-03.0lc"},
                                   {"\t\t亄", "%0lc"},
                                   {"         ᐃ       ", "%lc"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    wchar_t result_first_arg[LEN] = {0};
    wchar_t expected_first_arg[LEN] = {0};
    int result = 0;
    int expected_result = 0;
    result =
        s21_sscanf(testcases[i].data, testcases[i].format, result_first_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, expected_first_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert(!wcscmp(result_first_arg, expected_first_arg));
  }
}
END_TEST

START_TEST(sscanf_c_multy) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"xyz", "%c%c%c"},      {"w e", "%c%c%c"},
      {"x y z", "%1c%0c%2c"}, {"w%el", "%%%c%%%c%%%c"},
      {"new", "%2c%2c%2c"},   {"%%%", "%%%c%%"},
      {"", "%c%c%c"},         {"sqewqrqw", "%3c%-23c%mc"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
#define m 3

  for (s21_size_t i = 0; i < n; i++) {
    char result_args[m][LEN] = {"", "", ""};
    char expected_args[m][LEN] = {"", "", ""};
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, result_args[0],
                        result_args[1], result_args[2]);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, expected_args[0],
               expected_args[1], expected_args[2]);
    ck_assert_int_eq(expected_result, result);
    for (s21_size_t j = 0; j < m; j++) {
      ck_assert_pstr_eq(result_args[j], expected_args[j]);
    }
  }
#undef m
}
END_TEST

START_TEST(sscanf_lc_multy) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"xyz", "%lc%lc%lc"},
                                   {"w e", "%lc%lc%lc"},
                                   {"आदमी अनाज का कीड़ा है।", "%3lc%2lc%lc"},
                                   {"כלב נובח לא נושך", "%0lc%3lc%5lc"},
                                   {"%%%%%%%%%", "%%%lc%%%lc%%%lc"},
                                   {"\t\n X", "%lc%lc"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
#define m 3

  for (s21_size_t i = 0; i < n; i++) {
    wchar_t result_args[m][LEN] = {L"", L"", L""};
    wchar_t expected_args[m][LEN] = {L"", L"", L""};
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, result_args[0],
                        result_args[1], result_args[2]);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, expected_args[0],
               expected_args[1], expected_args[2]);
    ck_assert_int_eq(expected_result, result);
    for (s21_size_t j = 0; j < m; j++) {
      ck_assert(!wcscmp(result_args[j], expected_args[j]));
    }
  }
#undef m
}
END_TEST

START_TEST(sscanf_s_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"xyz", "%s"},    {"w e", "%2s"},
                                   {"x y z", "%0s"}, {"w%el", "%%%s"},
                                   {"new", "%9s"},   {"%%%", "%%%s"},
                                   {"", "%15s"},     {"sqewqrqw", "%-39,3s"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result_arg[LEN] = "";
    char expected_arg[LEN] = "";
    int result = 0;
    int expected_result = 0;
    result =
        s21_sscanf(testcases[i].data, testcases[i].format, (char *)result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, (char *)expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_pstr_eq(result_arg, expected_arg);
  }
}
END_TEST

START_TEST(sscanf_ls_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"абобус", "%ls"},     {"     \n   ", "%ls"},  {"☺😉😘😡", "%0ls"},
      {"%αβγ", "%%%2ls"},    {"       ΠΣΞ", "%1ls"}, {"", "%90ls"},
      {"iqwsx", "%-42.88ls"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    wchar_t result_arg[LEN] = {0};
    wchar_t expected_arg[LEN] = {0};
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert(!wcscmp(expected_arg, result_arg));
  }
}
END_TEST

START_TEST(sscanf_di_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%d"},
                                   {"--123", "%%%d"},
                                   {"0x123", "%4d"},
                                   {"00000123", "%4d"},
                                   {"+4.2", "%2d"},
                                   {"2147483647", "%d"},
                                   {"abs%23", "abs%%%d"},
                                   {"abs%23", "%%%d"},
                                   {"      9 0", "%3d"},
                                   {"", "%15d"},
                                   {"0x123", "%i"},
                                   {"0X123", "%2i"},
                                   {"0123", "%3i"},
                                   {"0b00110011", "%5i"},
                                   {"0X AA", "%8i"},
                                   {"0x123456789ABCDEF", "%i"},
                                   {"0123456708910", "%i"},
                                   {"0X123456789ABCDEF", "%i"},
                                   {"0x123456789abcdef", "%i"},
                                   {"0X123456789abcdef", "%i"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    int result_arg = 0;
    int expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_int_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_hdi_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%hd"},
                                   {"--123", "%%%hd"},
                                   {"0x123", "%4hd"},
                                   {"00000123", "%4hd"},
                                   {"+4.2", "%2hd"},
                                   {"2147483647", "%hd"},
                                   {"abs%23", "abs%%%hd"},
                                   {"abs%23", "%%%hd"},
                                   {"      9 0", "%3hd"},
                                   {"", "%15hd"},
                                   {"0x123", "%hi"},
                                   {"0X123", "%2hi"},
                                   {"0123", "%3hi"},
                                   {"0b00110011", "%5hi"},
                                   {"0X AA", "%8hi"},
                                   {"0x123456789ABCDEF", "%hi"},
                                   {"0123456708910", "%hi"},
                                   {"0X123456789ABCDEF", "%hi"},
                                   {"0x123456789abcdef", "%hi"},
                                   {"0X123456789abcdef", "%hi"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    int result_arg = 0;
    int expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_int_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_ldi_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"123", "%ld"},          {"--123", "%%%ld"},
      {"0x123", "%4ld"},       {"00000123", "%4ld"},
      {"+4.2", "%2ld"},        {"-922337203685477", "%ld"},
      {"abs%23", "abs%%%ld"},  {"+abs%23", "%%%ld"},
      {"      9 0", "%3ld"},   {"", "%15ld"},
      {"0x123", "%li"},        {"-0X123", "%2li"},
      {"0123", "%3li"},        {"+0b00110011", "%5li"},
      {"0X AA", "%8li"},       {"0x123456789ABCDEF", "%li"},
      {"0123456708910", "%li"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    long result_arg = 0;
    long expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_int_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_di_multy) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%1d%1d%1d"},
                                   {"--123", "%%%d%1d%1d"},
                                   {"0x123", "%1ld%1d%1d"},
                                   {"00000123", "%4d%2d%1ld"},
                                   {"+4.2", "%2ld%3d%d"},
                                   {"123456789101112131415161", "%15ld%5ld%d"},
                                   {"abs%23", "abs%%%1ld%1ld%1ld"},
                                   {"abs%23", "%%%ld%ld%ld"},
                                   {"      9 0 8", "%3ld%ld%d"},
                                   {"", "%15ld%15ld%15ld"},
                                   {"0X123 0123 123", "%3li%i%i"},
                                   {"0123", "%1li%1li%1li"},
                                   {"0b001 100 11", "%5li%li%li"},
                                   {"0X AA 0 123 123", "%8li%i%li"},
                                   {"0x123456789ABCDEF", "%2li%2li%2li"},
                                   {"0123456708910", "%li%i%i"},
                                   {"123a123a123", "%da%da%d"},
                                   {"0x93%0X93%093", "%i%%%i%%%i"},
                                   {"128\t\t0x123 9", "%d%i%d"},
                                   {"123nbe", "%1d%1i%nasd"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
#define m 3

  for (s21_size_t i = 0; i < n; i++) {
    long result_args[m] = {0};
    long expected_args[m] = {0};
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_args[0],
                        &result_args[1], &result_args[2]);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_args[0],
               &expected_args[1], &expected_args[2]);
    ck_assert_int_eq(expected_result, result);
    for (s21_size_t j = 0; j < m; j++) {
      ck_assert_int_eq(expected_args[j], result_args[j]);
    }
  }
#undef m
}
END_TEST

START_TEST(sscanf_uxXo_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%u"},
                                   {"--123", "%%%u"},
                                   {"0x123", "%4x"},
                                   {"00000123", "%4u"},
                                   {"00000123", "%4o"},
                                   {"+4.2", "%2u"},
                                   {"4294967295", "%u"},
                                   {"abs%23", "abs%%%u"},
                                   {"abs%23", "%%%u"},
                                   {"      9 0", "%3u"},
                                   {"", "%15u"},
                                   {"0x123", "%x"},
                                   {"-0X123", "%2X"},
                                   {"-0123", "%3o"},
                                   {"0b00110011", "%5u"},
                                   {"0X AA", "%8X"},
                                   {"+0x123456789ABCDEF", "%X"},
                                   {"+0123456708910", "%6o"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    unsigned result_arg = 0;
    unsigned expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_uint_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_luxXo_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%lu"},
                                   {"--123", "%%%lu"},
                                   {"0x123", "%4lx"},
                                   {"00000123", "%4lu"},
                                   {"00000123", "%4lo"},
                                   {"+4.2", "%2lu"},
                                   {"4294967295", "%lu"},
                                   {"abs%23", "abs%%%lu"},
                                   {"abs%23", "%%%lu"},
                                   {"      9 0", "%3lu"},
                                   {"", "%15lu"},
                                   {"0x123", "%lx"},
                                   {"0X123", "%2lX"},
                                   {"0123", "%3lo"},
                                   {"0b00110011", "%5lu"},
                                   {"+0X AA", "%8lX"},
                                   {"0x123456789ABCDEF", "%lX"},
                                   {"-0123456708910", "%6lo"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    unsigned long result_arg = 0;
    unsigned long expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_uint_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_huxXo_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%hu"},
                                   {"--123", "%%%hu"},
                                   {"0x123", "%4hx"},
                                   {"00000123", "%4hu"},
                                   {"00000123", "%4ho"},
                                   {"+4.2", "%2hu"},
                                   {"4294967295", "%hu"},
                                   {"abs%23", "abs%%%hu"},
                                   {"abs%23", "%%%hu"},
                                   {"      9 0", "%3hu"},
                                   {"", "%15hu"},
                                   {"0x123", "%hx"},
                                   {"0X123", "%2hX"},
                                   {"0123", "%3ho"},
                                   {"0b00110011", "%5hu"},
                                   {"0X AA", "%8hX"},
                                   {"0x123456789ABCDEF", "%hX"},
                                   {"0123456708910", "%6ho"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    unsigned short result_arg = 0;
    unsigned short expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_uint_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_uxXo_multy) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%1u%1u%1u"},
                                   {"--123", "%%%u%1u%1u"},
                                   {"0x123", "%1x%1u%1o"},
                                   {"00000123", "%4o%2o%1u"},
                                   {"+4.2", "%2u%u%u"},
                                   {"1234567891011121675", "%15u%5x%o"},
                                   {"abs%23", "abs%%%1u%1u%1u"},
                                   {"abs%23", "%%%u%o%x"},
                                   {"      9 0 8", "%3u%lX%o"},
                                   {"", "%15X%15u%15o"},
                                   {"0x123", "%1X%1o%1x"},
                                   {"0X123 0123 123", "%X%o%x"},
                                   {"0123", "%1o%1o%1o"},
                                   {"0b001 100 11", "%5u%o%x"},
                                   {"0X AA 0 123 123", "%8x%o%u"},
                                   {"0x123456789ABCDEF", "%2x%2o%2u"},
                                   {"0123456708910", "%3o%3u%3x"},
                                   {"123a123a123", "%ua%ua%u"},
                                   {"0x93%0X93%093", "%X%%%x%%%o"},
                                   {"128\t\t0x123 9", "%u%x%u"},
                                   {"123nbe", "%1u%1u%nasd"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
#define m 3

  for (s21_size_t i = 0; i < n; i++) {
    unsigned result_args[m] = {0};
    unsigned expected_args[m] = {0};
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_args[0],
                        &result_args[1], &result_args[2]);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_args[0],
               &expected_args[1], &expected_args[2]);
    ck_assert_int_eq(expected_result, result);
    for (s21_size_t j = 0; j < m; j++) {
      ck_assert_uint_eq(expected_args[j], result_args[j]);
    }
  }
#undef m
}
END_TEST

START_TEST(sscanf_p_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {{"123", "%p"},
                                   {"%-123", "%p"},
                                   {"0x123", "%4p"},
                                   {"-0x123", "%4p"},
                                   {"00000123", "%4p"},
                                   {"+4.2", "%2p"},
                                   {"0X0000282930", "%2p"},
                                   {"abs%0x123", "abs%%%p"},
                                   {"abs%23", "%%%p"},
                                   {"      0x13219141924", "%p"},
                                   {"", "%15p"},
                                   {"0 x12385923", "%p"},
                                   {"%%%abd0x12345678", "%%%%%%abd%p"},
                                   {"0123", "%p"},
                                   {"0x0011x0011", "%p"},
                                   {"0XAA", "%0p"},
                                   {"-0XAA", "%0p"},
                                   {"-0XAA", "%p"},
                                   {"0x123456789ABCDEF", "%15p"},
                                   {"0x123456789abcdefz", "%15p"},
                                   {"0123456708910", "%2p"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    void *result_arg = 0;
    void *expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_ptr_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_p_multy) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"123", "%1p%1p%1p"},
      {"--123", "%%%p%1p%1p"},
      {"0x1230x1230x123", "%1p%p%11p"},
      {"000x000x123", "%p%p%p"},
      {"123 0x123 0X123", "%p%p%p"},
      {"0x12345678A101112131415161718192021222324252627282930", "%15p%5p%p"},
      {"0x12345678A101112131415161718192021222324252627282930", "%p%5p%15p"},
      {"-0x12345678A101112131415161718192021222324252627282930", "%15p%5p%p"},
      {"-0x12345678A101112131415161718192021222324252627282930", "%p%5p%15p"},
      {"abs%2222222", "abs%%%1p%1p%1p"},
      {"abs%230x230X23", "%%%p%p%p"},
      {"      9 0 8", "%p%p%p"},
      {"0x923ABCDEF", "%15p%15p%15p"},
      {"0x123 123123", "%3p%3p%3p"},
      {"0X1230123123", "%3p%3p%3p"},
      {"0123", "%1p%1p%1p"},
      {"0b001 100 11", "%5p%p%p"},
      {"0X AA 0 123 123", "%8p%p%p"},
      {"0x1234560x789ABC0xDEF", "%2p%2p%2p"},
      {"0x123456789ABCDEF 0x12ABCDEF", "%p%2p%p"},
      {"0x1abcdef 0x1abcdef 0x1abcdef", "%pa%pa%p"},
      {"0x93%0X93%093", "%p%%%p%%%p"},
      {"128\t\t0x123 9", "%p%p%p"},
      {"123nbe", "%1p%1p%nasd"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
#define m 3

  for (s21_size_t i = 0; i < n; i++) {
    void *result_args[m] = {0};
    void *expected_args[m] = {0};
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_args[0],
                        &result_args[1], &result_args[2]);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_args[0],
               &expected_args[1], &expected_args[2]);
    ck_assert_int_eq(expected_result, result);
    for (s21_size_t j = 0; j < m; j++) {
      ck_assert_ptr_eq(expected_args[j], result_args[j]);
    }
  }
#undef m
}
END_TEST

START_TEST(sscanf_feEgG_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"1.234", "%f"},
      {"123456789e-8", "%e"},
      {"29e3330", "%4E"},
      {"00000123.", "%g"},
      {"+4...2", "%G"},
      {"0X0000282930", "%2e"},
      {"123456789101112131415161718192021.21222324252627291242141525512515",
       "%Eabcd"},
      {"abs%23", "abs%%%f"},
      {"      0. 13219141924", "%23g"},
      {"", "%15G"},
      {".12385923", "%f"},
      {"%%%abd-12345667777.235215151", "%%%%%%abd%e"},
      {"-----78247328.1321512", "%E"},
      {"++++1.23", "%2g"},
      {"19.2", "%0G"},
      {" 2.\t23", "%15f"},
      {"123,123", "%15e"},
      {"0123456708910", "%2E"},
      {"1234e1234", "%6g"},
      {"1234E1234", "%5G"},
      {"+123e+123", "%f"},
      {"-123E+123", "%f"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    float result_arg = 0;
    float expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_double_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_lfeEgG_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"1.234", "%lf"},
      {"123456789e-8", "%le"},
      {"29e3330", "%4lE"},
      {"00000123.", "%lg"},
      {"+4...2", "%lG"},
      {"0X0000282930", "%2le"},
      {"123456789101112131415161718192021.21222324252627291242141525512515",
       "%lEabcd"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    double result_arg = 0;
    double expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_double_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_LfeEgG_single) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"1.234", "%Lf"},
      {"123456789e-8", "%Le"},
      {"29e3330", "%4LE"},
      {"00000123.", "%Lg"},
      {"+4...2", "%LG"},
      {"0X0000282930", "%2Le"},
      {"123456789101112131415161718192021.21222324252627291242141525512515",
       "%LEabcd"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    long double result_arg = 0;
    long double expected_arg = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_arg);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_arg);
    ck_assert_int_eq(expected_result, result);
    ck_assert_double_eq(expected_arg, result_arg);
  }
}
END_TEST

START_TEST(sscanf_feEgG_multy) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"1.2345.67.89", "%f%f%f"},
      {"1234e-856e789e-8", "%e%e%e"},
      {"29e33E3E0", "%4E%E%E"},
      {"0.0000123.2.", "%g%g%g"},
      {"+4.2.3..2", "%G%G%G"},
      {"0e0 000 282930", "%2e%3e%3e"},
      {"1234eeeeeee+123", "%8f%8e%8g"},
      {"1234567.89101112131415161718192021.2122232425262729.1242141525512515",
       "%E%15E%30E"},
      {"abs%234.1", "abs%%%1f%1f%f"},
      {"      0. 13219141924.", "%23g%23f%23e"},
      {"2", "%15G%40e%12359349g"},
      {".12385923", "%2f%3f%4f"},
      {"%%%abd-12345667777.235215151 1e e+8", "%%%%%%abd%e%e%e"},
      {"-----78247328.1321512 8e------2 0.", "%E%E%e"},
      {"++++1.2.3.", "%2g%1g%1g"},
      {"19.2 e 1e1", "%0G%0G%0G"},
      {" 2.\t23\n234", "%15f%15f%1f"},
      {"123,123,123", "%e%e%e"},
      {"0123456708910", "%2E%2E%2E"},
      {"1234e1234e1234e", "%6g%6g%6g"},
      {"1234E1234E1234E", "%5G%5G%5G"},
      {"+123e+123 +123E+123", "%f%f%f"},
      {"-123E+123 +123E-123 E", "%f%f%f"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);
#define m 3

  for (s21_size_t i = 0; i < n; i++) {
    float result_args[m] = {0};
    float expected_args[m] = {0};
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, &result_args[0],
                        &result_args[1], &result_args[2]);
    expected_result =
        sscanf(testcases[i].data, testcases[i].format, &expected_args[0],
               &expected_args[1], &expected_args[2]);
    ck_assert_int_eq(expected_result, result);
    for (s21_size_t j = 0; j < m; j++) {
      ck_assert_double_eq(expected_args[j], result_args[j]);
    }
  }
#undef m
}
END_TEST

START_TEST(sscanf_n) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"123123 ", "%d%n"},    {"1.23e+12", "%e%n"},  {"anwed", "%c%n"},
      {"арбуз ", "%lc %n"},   {"hehehe", "%s%n"},    {"хехехе ", "%ls %n"},
      {"         ", " %s%n"}, {"          ", "%n%n"}};

  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result_arg[LEN] = {0};
    char expected_args[LEN] = {0};
    int result_length = 0;
    int expected_length = 0;
    int result = 0;
    int expected_result = 0;
    result = s21_sscanf(testcases[i].data, testcases[i].format, result_arg,
                        &result_length);
    expected_result = sscanf(testcases[i].data, testcases[i].format,
                             expected_args, &expected_length);
    ck_assert_int_eq(expected_result, result);
    ck_assert_pstr_eq(expected_args, result_arg);
    ck_assert_int_eq(expected_length, result_length);
  }
}
END_TEST

START_TEST(sscanf_hard) {
  struct input_data {
    const char *data;
    const char *format;
  };
  struct input_data testcases[] = {
      {"Hardacock 	 -13hard+13cockabobahard0x0000ABCDEFcock 	  "
       "0123hard"
       "0X123cock1.23hard1.33e+123cock ",
       "Hard%ccock %dhard%ucock%5shard%p%ncock   %ohard%Xcock%lfhard%LEcock"},
      {"Hardjabcock -13 hard ++13 cock bebra\thard\n-0XABD cock "
       "--0XABD hard 0x88 cock 1.33e hard -99e-99 cock",
       "Hard%3ccock%0uhard%icock%0shard%8icock%ihard%pcock%lghard%LGcock"},
      {"Harda   cock-13hard+13cockabobahard   0x0000ABCDEFcock0123hard"
       "0X123cock1.23hard1.33e+123cock ",
       "Hard%*c cock%*dhard%*ucock%*9s %*p%*ncock%*ohard%*Xcock%*lfhard%*"
       "LEcock"}};
  s21_size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (s21_size_t i = 0; i < n; i++) {
    char result1[LEN] = {0};
    int result2 = 0;
    unsigned result3 = 0;
    char result4[LEN] = {0};
    void *result5 = 0;
    unsigned result6 = 0;
    unsigned result7 = 0;
    double result8 = 0;
    long double result9 = 0;
    char expected1[LEN] = {0};
    int expected2 = 0;
    unsigned expected3 = 0;
    char expected4[LEN] = {0};
    void *expected5 = 0;
    unsigned expected6 = 0;
    unsigned expected7 = 0;
    double expected8 = 0;
    long double expected9 = 0;
    int returned_result = 0;
    int returned_expected = 0;
    returned_result = s21_sscanf(testcases[i].data, testcases[i].format,
                                 result1, &result2, &result3, result4, &result5,
                                 &result6, &result7, &result8, &result9);
    returned_expected =
        sscanf(testcases[i].data, testcases[i].format, expected1, &expected2,
               &expected3, expected4, &expected5, &expected6, &expected7,
               &expected8, &expected9);
    ck_assert_int_eq(returned_expected, returned_result);
    ck_assert_pstr_eq(expected1, result1);
    ck_assert_int_eq(expected2, result2);
    ck_assert_uint_eq(expected3, result3);
    ck_assert_pstr_eq(expected4, result4);
    ck_assert_ptr_eq(expected5, result5);
    ck_assert_uint_eq(expected6, result6);
    ck_assert_uint_eq(expected7, result7);
    ck_assert_double_eq(expected8, result8);
    ck_assert_ldouble_eq(expected9, result9);
  }
}
END_TEST

int main(void) {
  Suite *s1 = suite_create("string_basic_functions_suite");
  TCase *tc1_1 = tcase_create("additional_functions");
  TCase *tc1_2 = tcase_create("calculation_functions");
  TCase *tc1_3 = tcase_create("comparison_functions");
  TCase *tc1_4 = tcase_create("copying_functions");
  TCase *tc1_5 = tcase_create("search_functions");
  TCase *tc1_6 = tcase_create("special_processing_functions(bonus)");
  Suite *s2 = suite_create("string_sprintf_suite");
  TCase *tc2_1 = tcase_create("sprintf_format_test");
  Suite *s3 = suite_create("string_sscanf_suite");
  TCase *tc3_1 = tcase_create("sscanf_format_test");
  SRunner *sr = srunner_create(s1);
  int nf;

  /* User-specified pre-run code */
  setlocale(LC_ALL, "");

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, strcat_multy);
  tcase_add_test(tc1_1, strncat_multy);
  tcase_add_test(tc1_1, strerror_multy);
  tcase_add_test(tc1_1, strtok_multy);
  suite_add_tcase(s1, tc1_2);
  tcase_add_test(tc1_2, strlen_multy);
  tcase_add_test(tc1_2, strcspn_multy);
  tcase_add_test(tc1_2, strspn_multy);
  suite_add_tcase(s1, tc1_3);
  tcase_add_test(tc1_3, memcmp_multy);
  tcase_add_test(tc1_3, strcmp_multy);
  tcase_add_test(tc1_3, strncmp_multy);
  suite_add_tcase(s1, tc1_4);
  tcase_add_test(tc1_4, memcpy_multy);
  tcase_add_test(tc1_4, memmove_simple);
  tcase_add_test(tc1_4, memmove_crossmemory);
  tcase_add_test(tc1_4, memset_multy);
  tcase_add_test(tc1_4, strcpy_multy);
  tcase_add_test(tc1_4, strncpy_multy);
  suite_add_tcase(s1, tc1_5);
  tcase_add_test(tc1_5, memchr_multy);
  tcase_add_test(tc1_5, strchr_multy);
  tcase_add_test(tc1_5, strpbrk_multy);
  tcase_add_test(tc1_5, strrchr_multy);
  tcase_add_test(tc1_5, strstr_multy);
  suite_add_tcase(s1, tc1_6);
  tcase_add_test(tc1_6, to_upper_single);
  tcase_add_test(tc1_6, to_lower_single);
  tcase_add_test(tc1_6, insert_multy);
  tcase_add_test(tc1_6, trim_multy);
  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, sprintf_c_single);
  tcase_add_test(tc2_1, sprintf_lc_single);
  tcase_add_test(tc2_1, sprintf_c_multy);
  tcase_add_test(tc2_1, sprintf_s_single);
  tcase_add_test(tc2_1, sprintf_ls_single);
  tcase_add_test(tc2_1, sprintf_di_single);
  tcase_add_test(tc2_1, sprintf_hdi_single);
  tcase_add_test(tc2_1, sprintf_ldi_single);
  tcase_add_test(tc2_1, sprintf_p_single);
  tcase_add_test(tc2_1, sprintf_di_multy);
  tcase_add_test(tc2_1, sprintf_dioxu_long);
  tcase_add_test(tc2_1, sprintf_oxu_multy);
  tcase_add_test(tc2_1, sprintf_hoxu_multy);
  tcase_add_test(tc2_1, sprintf_loxu_multy);
  tcase_add_test(tc2_1, sprintf_f_single);
  tcase_add_test(tc2_1, sprintf_Lf_single);
  tcase_add_test(tc2_1, sprintf_e_single);
  tcase_add_test(tc2_1, sprintf_LE_single);
  tcase_add_test(tc2_1, sprintf_g_single);
  tcase_add_test(tc2_1, sprintf_LG_single);
  tcase_add_test(tc2_1, sprintf_feg_single_long);
  tcase_add_test(tc2_1, sprintf_hard);
  suite_add_tcase(s3, tc3_1);
  tcase_add_test(tc3_1, sscanf_c_single);
  tcase_add_test(tc3_1, sscanf_lc_single);
  tcase_add_test(tc3_1, sscanf_c_multy);
  tcase_add_test(tc3_1, sscanf_lc_multy);
  tcase_add_test(tc3_1, sscanf_s_single);
  tcase_add_test(tc3_1, sscanf_ls_single);
  tcase_add_test(tc3_1, sscanf_di_single);
  tcase_add_test(tc3_1, sscanf_hdi_single);
  tcase_add_test(tc3_1, sscanf_ldi_single);
  tcase_add_test(tc3_1, sscanf_di_multy);
  tcase_add_test(tc3_1, sscanf_uxXo_single);
  tcase_add_test(tc3_1, sscanf_luxXo_single);
  tcase_add_test(tc3_1, sscanf_huxXo_single);
  tcase_add_test(tc3_1, sscanf_uxXo_multy);
  tcase_add_test(tc3_1, sscanf_p_single);
  tcase_add_test(tc3_1, sscanf_p_multy);
  tcase_add_test(tc3_1, sscanf_feEgG_single);
  tcase_add_test(tc3_1, sscanf_lfeEgG_single);
  tcase_add_test(tc3_1, sscanf_LfeEgG_single);
  tcase_add_test(tc3_1, sscanf_feEgG_multy);
  tcase_add_test(tc3_1, sscanf_n);
  tcase_add_test(tc3_1, sscanf_hard);

  srunner_add_suite(sr, s2);
  srunner_add_suite(sr, s3);

  srunner_run_all(sr, CK_VERBOSE);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
